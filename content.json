{"meta":{"title":"开心每一天","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com"},"pages":[],"posts":[{"title":"事件模块命令源码解析","slug":"事件模块命令源码解析","date":"2018-11-14T06:26:03.000Z","updated":"2018-11-14T06:44:27.000Z","comments":true,"path":"2018/11/14/事件模块命令源码解析/","link":"","permalink":"http://yoursite.com/2018/11/14/事件模块命令源码解析/","excerpt":"","text":"对于nginx事件模块的介绍，已经在前面的blog中介绍过了。这里我们介绍一下配置文件中与事件模块有关的重要命令和它们的具体实现。下面是一个配置的例子。123456events&#123; worker_connections 1024; use epoll; multi_accept on; accept_mutex on;｝ worker_connections指令worker_connections命令控制每个worker能够建立的最大连接数。123456789static ngx_command_t ngx_event_core_commands[] = &#123; &#123; ngx_string(&quot;worker_connections&quot;), NGX_EVENT_CONF|NGX_CONF_TAKE1, ngx_event_connections, 0, 0, NULL &#125;, ......&#125; 上面的代码是该命令的定义，可以看出，该命令的解析函数是ngx_event_connections函数。下面是ngx_event_connections函数的核心代码：1234567891011121314static char *ngx_event_connections(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ...... //获取worker_connections命令后面的参数 value = cf-&gt;args-&gt;elts; //将参数赋值给ecf-&gt;connections ecf-&gt;connections = ngx_atoi(value[1].data, value[1].len); ...... //将ecf-&gt;connections赋值给cf-&gt;cycle-&gt;connection_n cf-&gt;cycle-&gt;connection_n = ecf-&gt;connections; return NGX_CONF_OK;&#125; 可以看到，我们在worker_connections命令后面写的参数被赋值给了cf-&gt;cycle-&gt;connection_n这个变量。那么cf-&gt;cycle-&gt;connection_n是干什么用的呢？我们看下下面这段代码。123456789101112static ngx_int_tngx_event_process_init(ngx_cycle_t *cycle)&#123; ...... /* 分配连接池空间 */ cycle-&gt;connections = ngx_alloc(sizeof(ngx_connection_t) * cycle-&gt;connection_n, cycle-&gt;log); if (cycle-&gt;connections == NULL) &#123; return NGX_ERROR; &#125; ......&#125; ngx_event_process_init函数是在每个worker初始化的时候调用的。在该函数中，会为每个worker分配一个连接池。worker每建立一个新连接，都需要从连接池中获取一个ngx_connection_t结构体来记录连接的信息，连接断开后会把该结构体释放，重新放回到worker的连接池中。可以看到，这里开辟了一个sizeof(ngx_connection_t) * cycle-&gt;connection_n大小的空间，即每个worker最多同时建立cf-&gt;cycle-&gt;connection_n个连接。这也是使用worker_connections命令控制worker连接数的原理。 use指令use命令可以选择所使用的时间驱动模块。该命令的定义如下：12345678910static ngx_command_t ngx_event_core_commands[] = &#123; ...... &#123; ngx_string(&quot;use&quot;), NGX_EVENT_CONF|NGX_CONF_TAKE1, ngx_event_use, 0, 0, NULL &#125;, ......&#125; 在nginx源码中，使用ngx_event_use函数解析use命令。123456789101112131415161718192021222324static char *ngx_event_use(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ...... //遍历所有事件模块 for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123; if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_EVENT_MODULE) &#123; continue; &#125; //取出事件模块的信息 module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx; //将事件模块的名字与use后面的参数相比较 if (module-&gt;name-&gt;len == value[1].len) &#123; if (ngx_strcmp(module-&gt;name-&gt;data, value[1].data) == 0) &#123; //若相同，则赋值给ecf-&gt;use ecf-&gt;use = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index; ecf-&gt;name = module-&gt;name-&gt;data; ...... &#125; &#125; return NGX_CONF_OK; &#125; ......&#125; 上面是该函数的核心代码，该函数会遍历所有的NGX_EVENT_MODULE类型的模块，将use命令后面的参数与这些模块的模块名比较，如果相同，就会将该模块的ctx_index赋值给ecf-&gt;use变量。在后面初始化worker的时候，会根据ecf-&gt;use选择相应的事件驱动模块进行初始化。12345678910111213141516171819202122232425static ngx_int_tngx_event_process_init(ngx_cycle_t *cycle)&#123; ...... /* 调用要使用的event模块的ctx的action的init方法 */ for (m = 0; cycle-&gt;modules[m]; m++) &#123; if (cycle-&gt;modules[m]-&gt;type != NGX_EVENT_MODULE) &#123; continue; &#125; if (cycle-&gt;modules[m]-&gt;ctx_index != ecf-&gt;use) &#123; continue; &#125; module = cycle-&gt;modules[m]-&gt;ctx; if (module-&gt;actions.init(cycle, ngx_timer_resolution) != NGX_OK) &#123; /* fatal */ exit(2); &#125; break; &#125; ......&#125; 这里会根据ecf-&gt;use调用要使用的事件模块的ctx的action的init方法，如果我们使用的是epoll模块，则这里会调用ngx_epoll_init函数，为worker创建epoll结构体。 这里还有一个问题，如果我们没有使用use命令指定我们要使用的事件驱动模块，那nginx如何选择事件模块呢？首先，在安装nginx运行./configure命令的时候，脚本已经进行了一次筛选，选出操作系统支持的模块，只对这些模块进行编译。那如果操作系统支持多个模块呢？在ngx_event_core_init_conf函数中，会检查是否使用use指定了事件模块，如果没有则会根据优先级选择一个最优的模块。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static char *ngx_event_core_init_conf(ngx_cycle_t *cycle, void *conf)&#123; ...... #if (NGX_HAVE_EPOLL) &amp;&amp; !(NGX_TEST_BUILD_EPOLL) //测试是否支持epoll，如果支持让module为ngx_epoll_module fd = epoll_create(100); if (fd != -1) &#123; (void) close(fd); module = &amp;ngx_epoll_module; &#125; else if (ngx_errno != NGX_ENOSYS) &#123; module = &amp;ngx_epoll_module; &#125;#endif#if (NGX_HAVE_DEVPOLL) &amp;&amp; !(NGX_TEST_BUILD_DEVPOLL) //如果支持devpoll，让module等于ngx_devpoll_module module = &amp;ngx_devpoll_module;#endif#if (NGX_HAVE_KQUEUE) //如果支持kqueue，让module等于ngx_kqueue_module module = &amp;ngx_kqueue_module;#endif#if (NGX_HAVE_SELECT) //如果前面三者都不支持，让module等于ngx_select_module if (module == NULL) &#123; module = &amp;ngx_select_module; &#125;#endif //最后，如果前面四个都不支持，就选择modules数组中第一个事件模块 if (module == NULL) &#123; for (i = 0; cycle-&gt;modules[i]; i++) &#123; if (cycle-&gt;modules[i]-&gt;type != NGX_EVENT_MODULE) &#123; continue; &#125; event_module = cycle-&gt;modules[i]-&gt;ctx; if (ngx_strcmp(event_module-&gt;name-&gt;data, event_core_name.data) == 0) &#123; continue; &#125; module = cycle-&gt;modules[i]; break; &#125; &#125; ......&#125; 根据上面的代码，默认的事件模块的优先级为：kqueue &gt; devpoll &gt; epoll &gt; select &gt; 其他模块。 multi_accept指令我们知道在网络编程中，服务器在三次握手之后，需要调用accept函数分配一个新的套接字和客户端进行通信。multi_accept命令可以控制worker在收到accept事件的时候调用多次accept函数，与多个客户端建立通信。12345678910static ngx_command_t ngx_event_core_commands[] = &#123; ...... &#123; ngx_string(&quot;multi_accept&quot;), NGX_EVENT_CONF|NGX_CONF_FLAG, ngx_conf_set_flag_slot, 0, offsetof(ngx_event_conf_t, multi_accept), NULL &#125;, ......&#125; ngx_conf_set_flag_slot函数是nginx实现的一个解析配置的公用函数，该函数可以读取配置，将开关flag(on/off)保存在ngx_event_conf_t结构体中的multi_accept字段中。 nginx在收到accept事件的时候，都会调用ngx_event_accept函数。在该函数中，会使用ecf-&gt;multi_accept字段，控制worker调用accept函数的次数。1234567891011121314151617181920212223voidngx_event_accept(ngx_event_t *ev)&#123; ...... // 获取ngx_event_core_module模块的配置项参数结构 ecf = ngx_event_get_conf(ngx_cycle-&gt;conf_ctx, ngx_event_core_module); //将ecf-&gt;multi_accept赋值给ev-&gt;available if (!(ngx_event_flags &amp; NGX_USE_KQUEUE_EVENT)) &#123; ev-&gt;available = ecf-&gt;multi_accept; &#125; ...... do &#123; ...... // accept 建立一个新的连接 s = accept(lc-&gt;fd, &amp;sa.sockaddr, &amp;socklen); ...... //根据ev-&gt;available判断是否继续循环 &#125; while (ev-&gt;available);&#125; 由于一些事件模块如epoll只知道哪些端口有accept事件，并不知道该端口有多少accept事件，因此在worker调用epoll_wait函数获取到accept事件后，如果设置multi_accept为off，则只会与第一个发起请求的客户端进行accept，而其他的客户端的连接会在下一次调用epoll_wait函数时再处理。如果设置multi_accept为on，则会进入上面的do{......}while()循环中，会一直调用accept函数直到其返回-1为止，即一次便处理该监听端口的所有请求。 accept_mutex指令当多个worker都处于监听端口状态，如果突然来了一个请求，就会同时唤醒多个worker，但是只有一个worker会处理该请求，这就造成系统资源浪费，这个现象称作“惊群”。为了解决这个问题，nginx引用了一个锁。各个worker首先会进行抢锁，抢到锁的worker才会进行监听端口。 我们首先看一下accept_mutex指令的解析。12345678910static ngx_command_t ngx_event_core_commands[] = &#123; ...... &#123; ngx_string(&quot;accept_mutex&quot;), NGX_EVENT_CONF|NGX_CONF_FLAG, ngx_conf_set_flag_slot, 0, offsetof(ngx_event_conf_t, accept_mutex), NULL &#125;, ......&#125; 和上面的multi_accept命令一样，accept_mutex也会调用ngx_conf_set_flag_slot函数进行配置解析，将解析处理的参数存储在ngx_event_conf_t结构体中的accept_mutex字段中。 在worker初始化的过程中，会调用ngx_event_process_init函数，判断是否使用防止惊群的锁。123456789101112131415161718static ngx_int_tngx_event_process_init(ngx_cycle_t *cycle)&#123; ...... //如果nginx是多进程模式，worker数大于1，且ecf-&gt;accept_mutex为1，则打开锁 if (ccf-&gt;master &amp;&amp; ccf-&gt;worker_processes &gt; 1 &amp;&amp; ecf-&gt;accept_mutex) &#123; ngx_use_accept_mutex = 1; ngx_accept_mutex_held = 0; ngx_accept_mutex_delay = ecf-&gt;accept_mutex_delay; &#125; else &#123; //否则不使用锁 ngx_use_accept_mutex = 0; &#125; ......&#125; 从上面的代码可以看出，如果设置accept_mutex为on，全局变量ngx_use_accept_mutex在worker初始化的时候会设置为1，若设置为off则ngx_use_accept_mutex会被设置为0。 后面nginx会在ngx_process_events_and_timers函数处理nginx事件的时候使用ngx_use_accept_mutex变量，控制是否使用锁。123456789101112131415161718192021222324252627282930313233voidngx_process_events_and_timers(ngx_cycle_t *cycle)&#123; ...... // 是否使用accept_mutex if (ngx_use_accept_mutex) &#123; // 该worker是否负载过高，若负载过高则不抢锁 if (ngx_accept_disabled &gt; 0) &#123; ngx_accept_disabled--; &#125; else &#123; // 进行抢锁 if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123; return; &#125; if (ngx_accept_mutex_held) &#123; // 抢到锁 flags |= NGX_POST_EVENTS; &#125; else &#123; // 未抢到锁，要修改worker在epoll_wait函数等待的时间 if (timer == NGX_TIMER_INFINITE || timer &gt; ngx_accept_mutex_delay) &#123; timer = ngx_accept_mutex_delay; &#125; &#125; &#125; &#125; ......&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-14T03:14:18.000Z","updated":"2018-11-14T03:14:18.000Z","comments":true,"path":"2018/11/14/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}